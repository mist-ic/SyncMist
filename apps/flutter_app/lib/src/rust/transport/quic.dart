// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'quic.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_cert_and_key`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `TofuCertVerifier`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `fmt`, `supported_verify_schemes`, `verify_server_cert`, `verify_tls12_signature`, `verify_tls13_signature`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `receive_data`

/// Generate a self-signed certificate for QUIC transport
///
/// Returns a tuple of (certificate, private_key) for use with the QUIC endpoint.
(Uint8List, Uint8List) generateSelfSignedCert() => RustLib.instance.api.crateTransportQuicGenerateSelfSignedCert();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuicTransport>>
abstract class QuicTransport implements RustOpaqueInterface {
  /// Accept an incoming connection (server only)
  Future<String> acceptConnection();

  /// Close the transport and all connections
  Future<void> close();

  /// Connect to a peer (client mode)
  ///
  /// # Arguments
  /// * `addr` - IP address or hostname of the peer
  /// * `port` - Port number of the peer
  Future<String> connectToPeer({required String addr, required int port});

  static QuicTransport default_() => RustLib.instance.api.crateTransportQuicQuicTransportDefault();

  /// Disconnect from a peer
  Future<void> disconnect({required String peerId});

  /// Get list of connected peers
  Future<List<String>> getConnectedPeers();

  /// Check if transport is running
  bool isRunning();

  /// Create a new QUIC transport instance
  factory QuicTransport() => RustLib.instance.api.crateTransportQuicQuicTransportNew();

  /// Send data to a specific peer
  ///
  /// # Arguments
  /// * `peer_id` - The peer identifier (address:port)
  /// * `data` - Data to send
  Future<void> sendData({required String peerId, required List<int> data});

  /// Start the QUIC server on the specified port
  ///
  /// # Arguments
  /// * `port` - Port number to listen on
  Future<void> startServer({required int port});
}

@freezed
sealed class TransportError with _$TransportError implements FrbException {
  const TransportError._();

  /// Connection error
  const factory TransportError.connection(
    String field0,
  ) = TransportError_Connection;

  /// IO error
  const factory TransportError.io(
    String field0,
  ) = TransportError_Io;

  /// TLS error
  const factory TransportError.tls(
    String field0,
  ) = TransportError_Tls;

  /// Not connected to any endpoint
  const factory TransportError.notConnected() = TransportError_NotConnected;

  /// Peer not found in connections
  const factory TransportError.peerNotFound(
    String field0,
  ) = TransportError_PeerNotFound;
}
