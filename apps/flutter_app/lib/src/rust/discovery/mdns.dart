// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'mdns.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MdnsDiscovery>>
abstract class MdnsDiscovery implements RustOpaqueInterface {
  /// Get the list of currently discovered peers
  Future<List<PeerInfo>> getDiscoveredPeers();

  /// Create a new mDNS discovery instance
  factory MdnsDiscovery({required String deviceId, required String deviceName}) =>
      RustLib.instance.api.crateDiscoveryMdnsMdnsDiscoveryNew(deviceId: deviceId, deviceName: deviceName);

  /// Register this device on the network
  void register({required int port});

  /// Start browsing for peers on the network
  /// This starts a background task that populates discovered_peers
  void startBrowsing();

  /// Stop discovery and unregister service
  void stop();
}

@freezed
sealed class DiscoveryError with _$DiscoveryError implements FrbException {
  const DiscoveryError._();

  /// Failed to register service
  const factory DiscoveryError.registration(
    String field0,
  ) = DiscoveryError_Registration;

  /// Failed to browse for services
  const factory DiscoveryError.browse(
    String field0,
  ) = DiscoveryError_Browse;

  /// Failed to parse service info
  const factory DiscoveryError.parse(
    String field0,
  ) = DiscoveryError_Parse;
}

/// Information about a discovered peer
class PeerInfo {
  final String deviceId;
  final String deviceName;
  final List<String> addresses;
  final int port;
  final BigInt discoveredAt;

  const PeerInfo({
    required this.deviceId,
    required this.deviceName,
    required this.addresses,
    required this.port,
    required this.discoveredAt,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^ deviceName.hashCode ^ addresses.hashCode ^ port.hashCode ^ discoveredAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerInfo &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          deviceName == other.deviceName &&
          addresses == other.addresses &&
          port == other.port &&
          discoveredAt == other.discoveredAt;
}
